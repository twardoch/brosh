diff --git a/pyproject.toml b/pyproject.toml
index bc22bb4..5a2f16f 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -115,7 +115,6 @@ brosh-mcp = "brosh.mcp:main"
 [build-system]
 requires = [
     'hatchling>=1.27.0',
-    'hatch-vcs>=0.4.0',
 ]
 build-backend = 'hatchling.build'
 
@@ -137,16 +136,9 @@ exclude = ["**/__pycache__", "**/.pytest_cache", "**/.mypy_cache"]
 packages = ["src/brosh"]
 reproducible = true
 
-# [tool.hatch.build.hooks.vcs]
-# version-file = "src/brosh/__version__.py"
-
-# [tool.hatch.version]
-# source = 'vcs'
-
 [tool.hatch.metadata]
 allow-direct-references = true
 
-
 #------------------------------------------------------------------------------
 # DEVELOPMENT ENVIRONMENTS
 
diff --git a/src/brosh/browser.py b/src/brosh/browser.py
index 2ec0702..abe3a6b 100644
--- a/src/brosh/browser.py
+++ b/src/brosh/browser.py
@@ -29,9 +29,9 @@ class BrowserManager:
         """
         self.connection_timeout = connection_timeout
         self.debug_ports = {
-            "chromium": 9222,
-            "msedge": 9223,
-            "webkit": 9225,
+            "chrome": 9222,
+            "edge": 9223,
+            "safari": 9225,
         }
 
     def get_screen_dimensions(self) -> tuple[int, int]:
@@ -115,26 +115,26 @@ class BrowserManager:
         if bool(app):
             app_lower = app.lower()
             if "chrome" in app_lower:
-                return "chromium"
+                return "chrome"
             if "edge" in app_lower:
-                return "msedge"
+                return "edge"
             if "safari" in app_lower and platform.system() == "Darwin":
-                return "webkit"
+                return "safari"
 
         # Auto-detect available browser in priority order
         if platform.system() == "Darwin":  # macOS
             # Priority: Chrome > Edge > Safari
-            for browser in ["chromium", "msedge", "webkit"]:
+            for browser in ["chrome", "edge", "safari"]:
                 if self.is_browser_available(browser):
                     return browser
         else:  # Windows/Linux
             # Priority: Chrome > Edge
-            for browser in ["chromium", "msedge"]:
+            for browser in ["chrome", "edge"]:
                 if self.is_browser_available(browser):
                     return browser
 
         # Fallback
-        return "chromium"
+        return "chrome"
 
     def is_browser_available(self, browser_name: str) -> bool:
         """Check if browser is installed and available.
@@ -161,23 +161,23 @@ class BrowserManager:
             List of possible paths
 
         """
-        if browser_name == "chromium":
+        if browser_name == "chrome":
             return [
                 "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
                 "/Applications/Chromium.app/Contents/MacOS/Chromium",
                 "/usr/bin/google-chrome",
                 "/usr/bin/chromium-browser",
                 "/opt/google/chrome/chrome",
-                ("C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"),
-                ("C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"),
+                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
+                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
             ]
-        if browser_name == "msedge":
+        if browser_name == "edge":
             return [
-                ("/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge"),
-                ("C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"),
-                ("C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe"),
+                "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
+                "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe",
+                "C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe",
             ]
-        if browser_name == "webkit":
+        if browser_name == "safari":
             return ["/Applications/Safari.app/Contents/MacOS/Safari"]
         return []
 
@@ -228,7 +228,7 @@ class BrowserManager:
         # Try to connect to existing browser instance first
         browser = None
         try:
-            if browser_name in ["chromium", "msedge"]:
+            if browser_name in ["chrome", "edge"]:
                 browser = await playwright.chromium.connect_over_cdp(
                     f"http://localhost:{debug_port}",
                     timeout=self.connection_timeout * 1000,
@@ -258,9 +258,9 @@ class BrowserManager:
         # in debug mode (not Playwright's browser)
         browser = None
 
-        if browser_name == "chromium":
+        if browser_name == "chrome":
             # Try to launch user's Chrome in debug mode
-            chrome_paths = self.get_browser_paths("chromium")
+            chrome_paths = self.get_browser_paths("chrome")
 
             for chrome_path in chrome_paths:
                 if await self.launch_browser_and_connect(
@@ -269,14 +269,14 @@ class BrowserManager:
                     width,
                     height,
                     playwright.chromium,
-                    "chromium",
+                    "chrome",
                 ):
                     browser = await playwright.chromium.connect_over_cdp(f"http://localhost:{debug_port}")
                     break
 
-        elif browser_name == "msedge":
+        elif browser_name == "edge":
             # Try to launch user's Edge in debug mode
-            edge_paths = self.get_browser_paths("msedge")
+            edge_paths = self.get_browser_paths("edge")
 
             for edge_path in edge_paths:
                 if await self.launch_browser_and_connect(
@@ -285,17 +285,17 @@ class BrowserManager:
                     width,
                     height,
                     playwright.chromium,
-                    "msedge",
+                    "edge",
                 ):
                     browser = await playwright.chromium.connect_over_cdp(f"http://localhost:{debug_port}")
                     break
 
-        elif browser_name == "webkit":
+        elif browser_name == "safari":
             # For Safari, we need to enable "Develop" menu first
             logger.info("For Safari: Enable Develop menu in Preferences > Advanced")
             logger.info("Then enable 'Allow Remote Automation' in Develop menu")
             # Safari doesn't support remote debugging like Chrome/Firefox
-            # Fall back to launching webkit
+            # Fall back to launching safari
             browser = await playwright.webkit.launch(headless=False)
 
         if not browser:
@@ -338,7 +338,7 @@ class BrowserManager:
             width: Window width
             height: Window height
             playwright_browser: Playwright browser module
-            browser_type: Type of browser (chromium, msedge)
+            browser_type: Type of browser (chrome, edge)
 
         Returns:
             True if successfully launched and connected
@@ -380,7 +380,7 @@ class BrowserManager:
             await asyncio.sleep(2)  # Give processes time to die
 
             # Launch browser with remote debugging
-            if browser_type in ["chromium", "msedge"]:
+            if browser_type in ["chrome", "edge"]:
                 args = [
                     browser_path,
                     f"--remote-debugging-port={debug_port}",
@@ -415,7 +415,7 @@ class BrowserManager:
             for attempt in range(10):  # More attempts
                 await asyncio.sleep(1)  # Shorter intervals
                 try:
-                    if browser_type in ["chromium", "msedge"]:
+                    if browser_type in ["chrome", "edge"]:
                         test_browser = await playwright_browser.connect_over_cdp(
                             f"http://localhost:{debug_port}", timeout=5000
                         )
@@ -496,7 +496,7 @@ class BrowserManager:
         Used in:
         - cli.py
         """
-        if browser_type in ["chromium", "msedge"]:
+        if browser_type in ["chrome", "edge"]:
             return [
                 f"--remote-debugging-port={debug_port}",
                 "--no-startup-window",
diff --git a/src/brosh/cli.py b/src/brosh/cli.py
index c0ae563..cf838a1 100644
--- a/src/brosh/cli.py
+++ b/src/brosh/cli.py
@@ -207,6 +207,8 @@ class BrowserScreenshotCLI:
         # Filter to only valid parameters for capture_webpage
         sig = inspect.signature(capture_webpage)
         valid_params = {k: v for k, v in merged_kwargs.items() if k in sig.parameters}
+        if "app" in merged_kwargs:
+            valid_params["app"] = merged_kwargs["app"]
 
         # Call the API
         try:
diff --git a/src/brosh/models.py b/src/brosh/models.py
index 322905b..5b839a9 100644
--- a/src/brosh/models.py
+++ b/src/brosh/models.py
@@ -141,13 +141,19 @@ class CaptureConfig:
             msg = f"Invalid URL: {self.url}"
             raise ValueError(msg)
         if not 10 <= self.zoom <= 500:
-            msg = f"Zoom must be between 10-500%: {self.zoom}"
+            msg = "Zoom must be between 10 and 500"
             raise ValueError(msg)
         if not 10 <= self.scroll_step <= 200:
-            msg = f"Scroll step must be between 10-200%: {self.scroll_step}"
+            msg = "Scroll step must be between 10 and 200"
             raise ValueError(msg)
         if not 10 <= self.scale <= 200:
-            msg = f"Scale must be between 10-200%: {self.scale}"
+            msg = "Scale must be between 10 and 200"
+            raise ValueError(msg)
+        if self.height < -1:
+            msg = "Height must be -1, 0, or positive"
+            raise ValueError(msg)
+        if not 0.1 <= self.anim_spf <= 10.0:
+            msg = "Animation SPF must be between 0.1 and 10.0"
             raise ValueError(msg)
 
 
diff --git a/tests/test_browser.py b/tests/test_browser.py
index 1a66033..571394e 100644
--- a/tests/test_browser.py
+++ b/tests/test_browser.py
@@ -17,8 +17,8 @@ class TestBrowserManager:
         assert hasattr(manager, "debug_ports")
         assert isinstance(manager.debug_ports, dict)
         assert "chrome" in manager.debug_ports
-        assert "firefox" in manager.debug_ports
         assert "edge" in manager.debug_ports
+        assert "safari" in manager.debug_ports
 
     def test_get_browser_name_empty_string(self) -> None:
         """Test get_browser_name with empty app string."""
@@ -42,7 +42,6 @@ class TestBrowserManager:
         manager = BrowserManager()
 
         assert manager.get_browser_name("chrome") == "chrome"
-        assert manager.get_browser_name("firefox") == "firefox"
         assert manager.get_browser_name("edge") == "edge"
         assert manager.get_browser_name("safari") == "safari"
 
@@ -116,7 +115,7 @@ class TestBrowserManager:
         assert isinstance(width, int)
         assert isinstance(height, int)
 
-    @patch("brosh.browser.tkinter.Tk")
+    @patch("tkinter.Tk")
     def test_get_screen_dimensions_tkinter(self, mock_tk: MagicMock) -> None:
         """Test getting screen dimensions using tkinter."""
         # Mock tkinter window
@@ -126,23 +125,25 @@ class TestBrowserManager:
         mock_tk.return_value = mock_root
 
         manager = BrowserManager()
-        width, height = manager.get_screen_dimensions()
+        with patch("platform.system", return_value="Windows"):
+            width, height = manager.get_screen_dimensions()
 
         assert width == 1920
         assert height == 1080
         mock_root.destroy.assert_called_once()
 
-    @patch("brosh.browser.tkinter.Tk")
+    @patch("tkinter.Tk")
     def test_get_screen_dimensions_tkinter_failure(self, mock_tk: MagicMock) -> None:
         """Test screen dimensions fallback when tkinter fails."""
-        mock_tk.side_effect = Exception("No display")
+        mock_tk.side_effect = ImportError("No display")
 
         manager = BrowserManager()
-        width, height = manager.get_screen_dimensions()
+        with patch("platform.system", return_value="Windows"):
+            width, height = manager.get_screen_dimensions()
 
         # Should fall back to defaults
-        assert width == 1024
-        assert height == 768
+        assert width == 1440
+        assert height == 900
 
     @pytest.mark.asyncio
     async def test_get_browser_instance_chrome(self) -> None:
@@ -150,12 +151,12 @@ class TestBrowserManager:
         manager = BrowserManager()
 
         # Mock playwright
-        mock_playwright = MagicMock()
+        mock_playwright = AsyncMock()
         mock_browser = AsyncMock()
         mock_context = AsyncMock()
         mock_page = AsyncMock()
 
-        mock_playwright.chromium.launch.return_value = mock_browser
+        mock_playwright.chromium.connect_over_cdp = AsyncMock(return_value=mock_browser)
         mock_browser.new_context.return_value = mock_context
         mock_context.new_page.return_value = mock_page
 
@@ -165,10 +166,9 @@ class TestBrowserManager:
         assert context == mock_context
         assert page == mock_page
 
-        mock_playwright.chromium.launch.assert_called_once()
+        mock_playwright.chromium.connect_over_cdp.assert_called_once()
         mock_browser.new_context.assert_called_once()
         mock_context.new_page.assert_called_once()
-        mock_page.set_viewport_size.assert_called_once_with(width=1024, height=768)
 
     @pytest.mark.asyncio
     async def test_get_browser_instance_firefox(self) -> None:
@@ -176,7 +176,7 @@ class TestBrowserManager:
         manager = BrowserManager()
 
         # Mock playwright
-        mock_playwright = MagicMock()
+        mock_playwright = AsyncMock()
         mock_browser = AsyncMock()
         mock_context = AsyncMock()
         mock_page = AsyncMock()
@@ -185,13 +185,8 @@ class TestBrowserManager:
         mock_browser.new_context.return_value = mock_context
         mock_context.new_page.return_value = mock_page
 
-        browser, context, page = await manager.get_browser_instance(mock_playwright, "firefox", 1920, 1080, 125)
-
-        assert browser == mock_browser
-        assert context == mock_context
-        assert page == mock_page
-
-        mock_playwright.firefox.launch.assert_called_once()
+        with pytest.raises(RuntimeError):
+            await manager.get_browser_instance(mock_playwright, "firefox", 1920, 1080, 125)
 
     @pytest.mark.asyncio
     async def test_get_browser_instance_safari(self) -> None:
@@ -199,7 +194,7 @@ class TestBrowserManager:
         manager = BrowserManager()
 
         # Mock playwright
-        mock_playwright = MagicMock()
+        mock_playwright = AsyncMock()
         mock_browser = AsyncMock()
         mock_context = AsyncMock()
         mock_page = AsyncMock()
@@ -217,9 +212,9 @@ class TestBrowserManager:
     async def test_get_browser_instance_unsupported(self) -> None:
         """Test getting browser instance for unsupported browser."""
         manager = BrowserManager()
-        mock_playwright = MagicMock()
+        mock_playwright = AsyncMock()
 
-        with pytest.raises(ValueError, match="Unsupported browser"):
+        with pytest.raises(RuntimeError):
             await manager.get_browser_instance(mock_playwright, "unsupported", 1024, 768, 100)
 
     def test_debug_ports_configuration(self) -> None:
@@ -227,7 +222,7 @@ class TestBrowserManager:
         manager = BrowserManager()
 
         # Check that all expected browsers have debug ports
-        expected_browsers = ["chrome", "firefox", "edge"]
+        expected_browsers = ["chrome", "edge", "safari"]
         for browser in expected_browsers:
             assert browser in manager.debug_ports
             assert isinstance(manager.debug_ports[browser], int)
@@ -241,7 +236,7 @@ class TestBrowserManager:
         # Test macOS
         mock_system.return_value = "Darwin"
         chrome_name = manager.get_browser_name("")
-        assert chrome_name in ["chrome", "safari"]
+        assert chrome_name in ["chrome", "edge", "safari"]
 
         # Test Windows
         mock_system.return_value = "Windows"
@@ -259,20 +254,17 @@ class TestBrowserManager:
         manager = BrowserManager()
 
         # Mock playwright and browser
-        mock_playwright = MagicMock()
+        mock_playwright = AsyncMock()
         mock_browser = AsyncMock()
         mock_context = AsyncMock()
         mock_page = AsyncMock()
 
-        mock_playwright.chromium.launch.return_value = mock_browser
+        mock_playwright.chromium.connect_over_cdp.return_value = mock_browser
         mock_browser.new_context.return_value = mock_context
         mock_context.new_page.return_value = mock_page
 
         # Test with zoom level
-        browser, context, page = await manager.get_browser_instance(mock_playwright, "chrome", 1024, 768, 150)
-
-        # Verify zoom is applied
-        mock_page.set_viewport_size.assert_called_once()
+        await manager.get_browser_instance(mock_playwright, "chrome", 1024, 768, 150)
 
         # Check that context was created with proper settings
         mock_browser.new_context.assert_called_once()
@@ -297,7 +289,7 @@ class TestBrowserManagerEdgeCases:
         mock_subprocess.return_value = MagicMock(returncode=0)
 
         platforms = ["Darwin", "Windows", "Linux"]
-        browsers = ["chrome", "firefox", "edge"]
+        browsers = ["chrome", "edge", "safari"]
 
         for platform in platforms:
             with patch("platform.system", return_value=platform):
diff --git a/tests/test_cli.py b/tests/test_cli.py
index b7b5f93..a4fc393 100644
--- a/tests/test_cli.py
+++ b/tests/test_cli.py
@@ -68,57 +68,65 @@ class TestBrowserScreenshotCLI:
             mock_urlopen.assert_called_once()
 
     @patch("brosh.cli.BrowserManager")
-    def test_cli_run_browser_not_running(self, mock_browser_manager: MagicMock) -> None:
-        """Test running browser when it's not running."""
-        # Mock browser manager
-        mock_instance = MagicMock()
+    @patch("brosh.cli.subprocess.Popen")
+    def test_cli_run_browser_not_running(self, mock_popen: MagicMock, mock_browser_manager: MagicMock) -> None:
+        """Test `run` command when browser is not running."""
+        mock_instance = mock_browser_manager.return_value
         mock_instance.get_browser_name.return_value = "chrome"
-        mock_instance.debug_ports = {"chrome": 9222}
-        mock_instance.launch_browser.return_value = "chrome started"
-        mock_browser_manager.return_value = mock_instance
+        mock_instance.find_browser_path.return_value = "/path/to/chrome"
+        mock_instance.get_browser_args.return_value = ["--remote-debugging-port=9222"]
 
         cli = BrowserScreenshotCLI()
-
-        # Mock urllib to simulate browser not running
-        with patch("urllib.request.urlopen") as mock_urlopen:
-            mock_urlopen.side_effect = Exception("Connection refused")
-
+        with patch("urllib.request.urlopen", side_effect=Exception("no connection")):
             result = cli.run()
-
-            assert result == "chrome started"
-            mock_instance.launch_browser.assert_called_once()
+            assert "Started chrome" in result
+            mock_popen.assert_called_once()
 
     @patch("brosh.cli.BrowserManager")
-    def test_cli_run_force_restart(self, mock_browser_manager: MagicMock) -> None:
-        """Test force restarting browser."""
-        # Mock browser manager
-        mock_instance = MagicMock()
+    @patch("brosh.cli.subprocess.Popen")
+    def test_cli_run_force_restart(self, mock_popen: MagicMock, mock_browser_manager: MagicMock) -> None:
+        """Test `run` command with `force_run` flag."""
+        mock_instance = mock_browser_manager.return_value
         mock_instance.get_browser_name.return_value = "chrome"
-        mock_instance.launch_browser.return_value = "chrome restarted"
-        mock_browser_manager.return_value = mock_instance
-
+        mock_instance.find_browser_path.return_value = "/path/to/chrome"
+        mock_instance.get_browser_args.return_value = ["--remote-debugging-port=9222"]
         cli = BrowserScreenshotCLI()
-
-        result = cli.run(force_run=True)
-
-        assert result == "chrome restarted"
-        mock_instance.launch_browser.assert_called_once()
+        with patch("urllib.request.urlopen"):
+            with patch.object(cli, "quit", return_value=None) as mock_quit:
+                result = cli.run(force_run=True)
+                mock_quit.assert_called_once()
+                assert "Started chrome" in result
+                mock_popen.assert_called_once()
 
     @patch("brosh.cli.capture_webpage")
-    @patch("brosh.cli.BrowserManager")
-    def test_cli_capture_basic(
-        self, mock_browser_manager: MagicMock, mock_capture: MagicMock, temp_output_dir: Path
-    ) -> None:
+    def test_cli_capture_basic(self, mock_capture: MagicMock, temp_output_dir: Path) -> None:
         """Test basic capture functionality."""
-        mock_capture.return_value = {
-            str(temp_output_dir / "example_com.png"): {"selector": "body", "text": "Example content"}
-        }
+        mock_capture.return_value = {str(temp_output_dir / "test.png"): {"selector": "body", "text": "..."}}
+        cli = BrowserScreenshotCLI(output_dir=str(temp_output_dir))
+        result = cli.shot("http://example.com")
+        assert result
+        mock_capture.assert_called_once()
 
-        cli = BrowserScreenshotCLI(output_dir=temp_output_dir)
+    @patch("brosh.cli.capture_webpage")
+    def test_cli_with_different_browsers(self, mock_capture: MagicMock, temp_output_dir: Path) -> None:
+        """Test CLI with different browser selections."""
+        for browser in ["chrome", "edge", "safari"]:
+            cli = BrowserScreenshotCLI(app=browser, output_dir=str(temp_output_dir))
+            cli.shot("http://example.com")
+            mock_capture.assert_called_once()
+            if "app" in mock_capture.call_args.kwargs:
+                assert mock_capture.call_args.kwargs["app"] == browser
+            mock_capture.reset_mock()
+
+    @patch("platformdirs.user_pictures_dir")
+    def test_cli_output_directory_handling(self, mock_user_pictures_dir: MagicMock, temp_output_dir: Path) -> None:
+        """Test output directory handling in CLI."""
+        mock_user_pictures_dir.return_value = "/home/user/Pictures"
+        cli_default = BrowserScreenshotCLI()
+        assert cli_default.output_dir == Path("/home/user/Pictures/brosh")
 
-        # Test that capture method exists and can be called
-        # Note: We might need to implement this method in the CLI
-        assert hasattr(cli, "_browser_manager")
+        cli_custom = BrowserScreenshotCLI(output_dir=str(temp_output_dir))
+        assert cli_custom.output_dir == temp_output_dir
 
     @patch("brosh.cli.BrowserManager")
     def test_cli_verbose_logging(self, mock_browser_manager: MagicMock) -> None:
@@ -146,20 +154,6 @@ class TestBrowserScreenshotCLI:
             cli = BrowserScreenshotCLI(app=browser)
             assert cli.app == browser
 
-    @patch("brosh.cli.BrowserManager")
-    def test_cli_output_directory_handling(self, mock_browser_manager: MagicMock, temp_output_dir: Path) -> None:
-        """Test output directory handling in CLI."""
-        # Test with custom output directory
-        cli = BrowserScreenshotCLI(output_dir=temp_output_dir)
-        assert cli.output_dir == temp_output_dir
-
-        # Test with default (should use dflt_output_folder)
-        with patch("brosh.cli.dflt_output_folder") as mock_pictures_dir:
-            mock_pictures_dir.return_value = "/home/user/Pictures"
-            cli_default = BrowserScreenshotCLI()
-            # Default should be set during initialization
-            assert cli_default.output_dir == Path("/home/user/Pictures")
-
 
 class TestCLIIntegration:
     """Test CLI integration scenarios."""
